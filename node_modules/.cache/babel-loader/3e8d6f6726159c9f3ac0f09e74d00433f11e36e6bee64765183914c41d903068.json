{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useRoutes = exports.getWorkingPath = exports.usePath = exports.getPath = exports.setPath = exports.navigate = exports.ParentContext = exports.getBasepath = exports.setBasepath = void 0;\nvar _react = _interopRequireDefault(require(\"react\"));\nvar _isNode = _interopRequireDefault(require(\"./isNode\"));\nvar _queryParams = require(\"./queryParams\");\nvar _interceptor = require(\"./interceptor\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nvar preparedRoutes = {};\nvar stack = {};\nvar componentId = 1;\nvar currentPath = _isNode.default ? '' : location.pathname;\nvar basePath = '';\nvar basePathRegEx = null;\nvar pathUpdaters = [];\n/**\r\n * Will define a base path that will be utilized in your routing and navigation.\r\n * To be called _before_ any routing or navigation happens.\r\n * @param {string} inBasepath\r\n */\n\nvar setBasepath = function setBasepath(inBasepath) {\n  basePath = inBasepath;\n  basePathRegEx = new RegExp('^' + basePath);\n};\n/**\r\n * Returns the currently used base path.\r\n * @returns {string}\r\n */\n\nexports.setBasepath = setBasepath;\nvar getBasepath = function getBasepath() {\n  return basePath;\n};\nexports.getBasepath = getBasepath;\nvar resolvePath = function resolvePath(inPath) {\n  if (_isNode.default) {\n    var url = require('url');\n    return url.resolve(currentPath, inPath);\n  }\n  var current = new URL(currentPath, location.href);\n  var resolved = new URL(inPath, current);\n  return resolved.pathname;\n};\nvar ParentContext = _react.default.createContext(null);\n/**\r\n * Pass a route string to this function to receive a regular expression.\r\n * The transformation will be cached and if you pass the same route a second\r\n * time, the cached regex will be returned.\r\n * @param {string} inRoute\r\n * @returns {Array} [RegExp, propList]\r\n */\n\nexports.ParentContext = ParentContext;\nvar prepareRoute = function prepareRoute(inRoute) {\n  if (preparedRoutes[inRoute]) {\n    return preparedRoutes[inRoute];\n  }\n  var preparedRoute = [new RegExp(\"\".concat(inRoute.substr(0, 1) === '*' ? '' : '^').concat(inRoute.replace(/:[a-zA-Z]+/g, '([^/]+)').replace(/\\*/g, '')).concat(inRoute.substr(-1) === '*' ? '' : '$'))];\n  var propList = inRoute.match(/:[a-zA-Z]+/g);\n  preparedRoute.push(propList ? propList.map(function (paramName) {\n    return paramName.substr(1);\n  }) : []);\n  preparedRoutes[inRoute] = preparedRoute;\n  return preparedRoute;\n};\n/**\r\n * Virtually navigates the browser to the given URL and re-processes all routers.\r\n * @param {string} url The URL to navigate to. Do not mix adding GET params here and using the `getParams` argument.\r\n * @param {boolean} [replace=false] Should the navigation be done with a history replace to prevent back navigation by the user\r\n * @param {object} [queryParams] Key/Value pairs to convert into get parameters to be appended to the URL.\r\n * @param {boolean} [replaceQueryParams=true] Should existing query parameters be carried over, or dropped (replaced)?\r\n */\n\nvar navigate = function navigate(url) {\n  var replace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var queryParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var replaceQueryParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  url = (0, _interceptor.interceptRoute)(currentPath, resolvePath(url));\n  if (!url || url === currentPath) {\n    return;\n  }\n  currentPath = url;\n  if (_isNode.default) {\n    setPath(url);\n    processStack();\n    updatePathHooks();\n    return;\n  }\n  var finalURL = basePathRegEx ? url.match(basePathRegEx) ? url : basePath + url : url;\n  window.history[\"\".concat(replace ? 'replace' : 'push', \"State\")](null, null, finalURL);\n  processStack();\n  updatePathHooks();\n  if (queryParams) {\n    (0, _queryParams.setQueryParams)(queryParams, replaceQueryParams);\n  }\n};\nexports.navigate = navigate;\nvar customPath = '/';\n/**\r\n * Enables you to manually set the path from outside in a nodeJS environment, where window.history is not available.\r\n * @param {string} inPath\r\n */\n\nvar setPath = function setPath(inPath) {\n  var url = require('url');\n  customPath = url.resolve(customPath, inPath);\n};\n/**\r\n * Returns the current path of the router.\r\n * @returns {string}\r\n */\n\nexports.setPath = setPath;\nvar getPath = function getPath() {\n  return customPath;\n};\n/**\r\n * This hook returns the currently used URI.\r\n * Works in a browser context as well as for SSR.\r\n *\r\n * _Heads up:_ This will make your component render on every navigation unless you set this hook to passive!\r\n * @param {boolean} [active=true] Will update the component upon path changes. Set to false to only retrieve the path, once.\r\n * @param {boolean} [withBasepath=false] Should the base path be left at the beginning of the URI?\r\n * @returns {string}\r\n */\n\nexports.getPath = getPath;\nvar usePath = function usePath() {\n  var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var withBasepath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var _React$useState = _react.default.useState(0),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    setUpdate = _React$useState2[1];\n  _react.default.useEffect(function () {\n    if (!active) {\n      return;\n    }\n    pathUpdaters.push(setUpdate);\n    return function () {\n      var index = pathUpdaters.indexOf(setUpdate);\n      if (index !== -1) {\n        pathUpdaters.splice(index, 1);\n      }\n    };\n  }, [setUpdate]);\n  return withBasepath ? currentPath : currentPath.replace(basePathRegEx, '');\n};\n/**\r\n * Render all components that use path hooks.\r\n */\n\nexports.usePath = usePath;\nvar updatePathHooks = function updatePathHooks() {\n  var now = Date.now();\n  pathUpdaters.forEach(function (cb) {\n    return cb(now);\n  });\n};\n/**\r\n * Called from within the router. This returns either the current windows url path\r\n * or a already reduced path, if a parent router has already matched with a finishing\r\n * wildcard before.\r\n * @param {string} [parentRouterId]\r\n * @returns {string}\r\n */\n\nvar getWorkingPath = function getWorkingPath(parentRouterId) {\n  if (!parentRouterId) {\n    return _isNode.default ? customPath : window.location.pathname.replace(basePathRegEx, '') || '/';\n  }\n  var stackEntry = stack[parentRouterId];\n  if (!stackEntry) {\n    throw 'wth';\n  }\n  return stackEntry.reducedPath !== null ? stackEntry.reducedPath || '/' : window.location.pathname;\n};\nexports.getWorkingPath = getWorkingPath;\nvar processStack = function processStack() {\n  return Object.values(stack).forEach(process);\n};\n/**\r\n * This function takes two objects and compares if they have the same\r\n * keys and their keys have the same values assigned, so the objects are\r\n * basically the same.\r\n * @param {object} objA\r\n * @param {object} objB\r\n * @return {boolean}\r\n */\n\nvar objectsEqual = function objectsEqual(objA, objB) {\n  var objAKeys = Object.keys(objA);\n  var objBKeys = Object.keys(objB);\n  var valueIsEqual = function valueIsEqual(key) {\n    return objB.hasOwnProperty(key) && objA[key] === objB[key];\n  };\n  return objAKeys.length === objBKeys.length && objAKeys.every(valueIsEqual);\n};\nif (!_isNode.default) {\n  window.addEventListener('popstate', function (e) {\n    var nextPath = (0, _interceptor.interceptRoute)(currentPath, location.pathname);\n    if (!nextPath || nextPath === currentPath) {\n      e.preventDefault();\n      e.stopPropagation();\n      history.pushState(null, null, currentPath);\n      return;\n    }\n    currentPath = nextPath;\n    if (nextPath !== location.pathname) {\n      history.replaceState(null, null, nextPath);\n    }\n    processStack();\n    updatePathHooks();\n  });\n}\nvar emptyFunc = function emptyFunc() {\n  return null;\n};\n/**\r\n * This will calculate the match of a given router.\r\n * @param {object} stackObj\r\n * @param {boolean} [directCall] If its not a direct call, the process function might trigger a component render.\r\n */\n\nvar process = function process(stackObj, directCall) {\n  var routerId = stackObj.routerId,\n    parentRouterId = stackObj.parentRouterId,\n    routes = stackObj.routes,\n    setUpdate = stackObj.setUpdate,\n    resultFunc = stackObj.resultFunc,\n    resultProps = stackObj.resultProps,\n    previousReducedPath = stackObj.reducedPath;\n  var currentPath = getWorkingPath(parentRouterId);\n  var route = null;\n  var targetFunction = null;\n  var targetProps = null;\n  var reducedPath = null;\n  var anyMatched = false;\n  for (var i = 0; i < routes.length; i++) {\n    var _routes$i = _slicedToArray(routes[i], 2);\n    route = _routes$i[0];\n    targetFunction = _routes$i[1];\n    var _ref = preparedRoutes[route] ? preparedRoutes[route] : prepareRoute(route),\n      _ref2 = _slicedToArray(_ref, 2),\n      regex = _ref2[0],\n      groupNames = _ref2[1];\n    var _result = currentPath.match(regex);\n    if (!_result) {\n      targetFunction = emptyFunc;\n      continue;\n    }\n    if (groupNames.length) {\n      targetProps = {};\n      for (var j = 0; j < groupNames.length; j++) {\n        targetProps[groupNames[j]] = _result[j + 1];\n      }\n    }\n    reducedPath = currentPath.replace(_result[0], '');\n    anyMatched = true;\n    break;\n  }\n  if (!stack[routerId]) {\n    return;\n  }\n  if (!anyMatched) {\n    route = null;\n    targetFunction = null;\n    targetProps = null;\n    reducedPath = null;\n  }\n  var funcsDiffer = resultFunc !== targetFunction;\n  var pathDiffer = reducedPath !== previousReducedPath;\n  var propsDiffer = true;\n  if (!funcsDiffer) {\n    if (!resultProps && !targetProps) {\n      propsDiffer = false;\n    } else {\n      propsDiffer = !(resultProps && targetProps && objectsEqual(resultProps, targetProps) === true);\n    }\n    if (!propsDiffer) {\n      if (!pathDiffer) {\n        return;\n      }\n    }\n  }\n  var result = funcsDiffer || propsDiffer ? targetFunction ? targetFunction(targetProps) : null : stackObj.result;\n  Object.assign(stack[routerId], {\n    result: result,\n    reducedPath: reducedPath,\n    matchedRoute: route,\n    passContext: route ? route.substr(-1) === '*' : false\n  });\n  if (!directCall && (funcsDiffer || propsDiffer || route === null)) {\n    setUpdate(Date.now());\n  }\n};\n/**\r\n * If a route returns a function, instead of a react element, we need to wrap this function\r\n * to eventually wrap a context object around its result.\r\n * @param RouteContext\r\n * @param originalResult\r\n * @returns {function(): *}\r\n */\n\nvar wrapperFunction = function wrapperFunction(RouteContext, originalResult) {\n  return function () {\n    return _react.default.createElement(RouteContext, null, originalResult.apply(originalResult, arguments));\n  };\n};\n/**\r\n * Pass an object to this function where the keys are routes and the values\r\n * are functions to be executed when a route matches. Whatever your function returns\r\n * will be returned from the hook as well into your react component. Ideally you would\r\n * return components to be rendered when certain routes match, but you are not limited\r\n * to that.\r\n * @param {object} routeObj {\"/someRoute\": () => <Example />}\r\n */\n\nvar useRoutes = function useRoutes(routeObj) {\n  // Each router gets an internal id to look them up again.\n  var _React$useState3 = _react.default.useState(componentId),\n    _React$useState4 = _slicedToArray(_React$useState3, 1),\n    routerId = _React$useState4[0];\n  var setUpdate = _react.default.useState(0)[1]; // Needed to create nested routers which use only a subset of the URL.\n\n  var parentRouterId = _react.default.useContext(ParentContext); // If we just took the last ID, increase it for the next hook.\n\n  if (routerId === componentId) {\n    componentId += 1;\n  } // Removes the router from the stack after component unmount - it won't be processed anymore.\n\n  _react.default.useEffect(function () {\n    return function () {\n      return delete stack[routerId];\n    };\n  }, [routerId]);\n  var stackObj = stack[routerId];\n  if (stackObj && stackObj.originalRouteObj !== routeObj) {\n    stackObj = null;\n  }\n  if (!stackObj) {\n    stackObj = {\n      routerId: routerId,\n      originalRouteObj: routeObj,\n      routes: Object.entries(routeObj),\n      setUpdate: setUpdate,\n      parentRouterId: parentRouterId,\n      matchedRoute: null,\n      reducedPath: null,\n      passContext: false,\n      result: null\n    };\n    stack[routerId] = stackObj;\n    process(stackObj, true);\n  }\n  _react.default.useDebugValue(stackObj.matchedRoute);\n  if (!stackObj.matchedRoute) {\n    return null;\n  }\n  var result = stackObj.result;\n  if (!stackObj.passContext) {\n    return result;\n  } else {\n    var RouteContext = function RouteContext(_ref3) {\n      var children = _ref3.children;\n      return _react.default.createElement(ParentContext.Provider, {\n        value: routerId\n      }, children);\n    };\n    if (typeof result === 'function') {\n      return wrapperFunction(RouteContext, result);\n    }\n    return _react.default.isValidElement(result) && result.type !== RouteContext ? _react.default.createElement(RouteContext, null, result) : result;\n  }\n};\nexports.useRoutes = useRoutes;","map":{"version":3,"names":["_react","_interopRequireDefault","require","_isNode","_queryParams","_interceptor","preparedRoutes","stack","componentId","currentPath","default","location","pathname","basePath","basePathRegEx","pathUpdaters","setBasepath","inBasepath","RegExp","getBasepath","resolvePath","inPath","url","resolve","current","URL","href","resolved","ParentContext","createContext","prepareRoute","inRoute","preparedRoute","concat","substr","replace","propList","match","push","map","paramName","navigate","arguments","length","undefined","queryParams","replaceQueryParams","interceptRoute","setPath","processStack","updatePathHooks","finalURL","window","history","setQueryParams","customPath","getPath","usePath","active","withBasepath","_React$useState","useState","_React$useState2","_slicedToArray","setUpdate","useEffect","index","indexOf","splice","now","Date","forEach","cb","getWorkingPath","parentRouterId","stackEntry","reducedPath","Object","values","process","objectsEqual","objA","objB","objAKeys","keys","objBKeys","valueIsEqual","key","hasOwnProperty","every","addEventListener","e","nextPath","preventDefault","stopPropagation","pushState","replaceState","emptyFunc","stackObj","directCall","routerId","routes","resultFunc","resultProps","previousReducedPath","route","targetFunction","targetProps","anyMatched","i","_routes$i","_ref","_ref2","regex","groupNames","_result","j","funcsDiffer","pathDiffer","propsDiffer","result","assign","matchedRoute","passContext","wrapperFunction","RouteContext","originalResult","createElement","apply","useRoutes","routeObj","_React$useState3","_React$useState4","useContext","originalRouteObj","entries","useDebugValue","_ref3","children","Provider","value","isValidElement","type"],"sources":["/Users/tomo/Documents/code/projects/react/retro-memories/node_modules/hookrouter/src/router.js"],"sourcesContent":["import React from 'react';\r\nimport isNode from './isNode';\r\nimport {setQueryParams} from './queryParams';\r\nimport {interceptRoute} from './interceptor';\r\n\r\nlet preparedRoutes = {};\r\nlet stack = {};\r\nlet componentId = 1;\r\nlet currentPath = isNode ? '' : location.pathname;\r\nlet basePath = '';\r\nlet basePathRegEx = null;\r\nconst pathUpdaters = [];\r\n\r\n/**\r\n * Will define a base path that will be utilized in your routing and navigation.\r\n * To be called _before_ any routing or navigation happens.\r\n * @param {string} inBasepath\r\n */\r\nexport const setBasepath = (inBasepath) => {\r\n\tbasePath = inBasepath;\r\n\tbasePathRegEx = new RegExp('^' + basePath);\r\n};\r\n\r\n/**\r\n * Returns the currently used base path.\r\n * @returns {string}\r\n */\r\nexport const getBasepath = () => basePath;\r\n\r\nconst resolvePath = (inPath) => {\r\n\tif (isNode) {\r\n\t\tconst url = require('url');\r\n\t\treturn url.resolve(currentPath, inPath);\r\n\t}\r\n\r\n\tconst current = new URL(currentPath, location.href);\r\n\tconst resolved = new URL(inPath, current);\r\n\treturn resolved.pathname;\r\n};\r\n\r\nexport const ParentContext = React.createContext(null);\r\n\r\n/**\r\n * Pass a route string to this function to receive a regular expression.\r\n * The transformation will be cached and if you pass the same route a second\r\n * time, the cached regex will be returned.\r\n * @param {string} inRoute\r\n * @returns {Array} [RegExp, propList]\r\n */\r\nconst prepareRoute = (inRoute) => {\r\n\tif (preparedRoutes[inRoute]) {\r\n\t\treturn preparedRoutes[inRoute];\r\n\t}\r\n\r\n\tconst preparedRoute = [\r\n\t\tnew RegExp(`${inRoute.substr(0, 1) === '*' ? '' : '^'}${inRoute.replace(/:[a-zA-Z]+/g, '([^/]+)').replace(/\\*/g, '')}${inRoute.substr(-1,) === '*' ? '' : '$'}`)\r\n\t];\r\n\r\n\tconst propList = inRoute.match(/:[a-zA-Z]+/g);\r\n\tpreparedRoute.push(\r\n\t\tpropList\r\n\t\t\t? propList.map(paramName => paramName.substr(1))\r\n\t\t\t: []\r\n\t);\r\n\r\n\tpreparedRoutes[inRoute] = preparedRoute;\r\n\treturn preparedRoute;\r\n};\r\n\r\n/**\r\n * Virtually navigates the browser to the given URL and re-processes all routers.\r\n * @param {string} url The URL to navigate to. Do not mix adding GET params here and using the `getParams` argument.\r\n * @param {boolean} [replace=false] Should the navigation be done with a history replace to prevent back navigation by the user\r\n * @param {object} [queryParams] Key/Value pairs to convert into get parameters to be appended to the URL.\r\n * @param {boolean} [replaceQueryParams=true] Should existing query parameters be carried over, or dropped (replaced)?\r\n */\r\nexport const navigate = (url, replace = false, queryParams = null, replaceQueryParams = true) => {\r\n\turl = interceptRoute(currentPath, resolvePath(url));\r\n\r\n\tif (!url || url === currentPath) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tcurrentPath = url;\r\n\r\n\tif (isNode) {\r\n\t\tsetPath(url);\r\n\t\tprocessStack();\r\n\t\tupdatePathHooks();\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst finalURL = basePathRegEx\r\n\t\t? url.match(basePathRegEx)\r\n\t\t\t? url\r\n\t\t\t: basePath + url\r\n\t\t:\r\n\t\turl;\r\n\r\n\twindow.history[`${replace ? 'replace' : 'push'}State`](null, null, finalURL);\r\n\tprocessStack();\r\n\tupdatePathHooks();\r\n\r\n\tif (queryParams) {\r\n\t\tsetQueryParams(queryParams, replaceQueryParams);\r\n\t}\r\n};\r\n\r\nlet customPath = '/';\r\n/**\r\n * Enables you to manually set the path from outside in a nodeJS environment, where window.history is not available.\r\n * @param {string} inPath\r\n */\r\nexport const setPath = (inPath) => {\r\n\tconst url = require('url');\r\n\tcustomPath = url.resolve(customPath, inPath);\r\n};\r\n\r\n/**\r\n * Returns the current path of the router.\r\n * @returns {string}\r\n */\r\nexport const getPath = () => customPath;\r\n\r\n/**\r\n * This hook returns the currently used URI.\r\n * Works in a browser context as well as for SSR.\r\n *\r\n * _Heads up:_ This will make your component render on every navigation unless you set this hook to passive!\r\n * @param {boolean} [active=true] Will update the component upon path changes. Set to false to only retrieve the path, once.\r\n * @param {boolean} [withBasepath=false] Should the base path be left at the beginning of the URI?\r\n * @returns {string}\r\n */\r\nexport const usePath = (active = true, withBasepath = false) => {\r\n\tconst [, setUpdate] = React.useState(0);\r\n\r\n\tReact.useEffect(() => {\r\n\t\tif (!active) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tpathUpdaters.push(setUpdate);\r\n\t\treturn () => {\r\n\t\t\tconst index = pathUpdaters.indexOf(setUpdate);\r\n\t\t\tif (index !== -1) {\r\n\t\t\t\tpathUpdaters.splice(index, 1);\r\n\t\t\t}\r\n\t\t};\r\n\t}, [setUpdate]);\r\n\r\n\treturn withBasepath ? currentPath : currentPath.replace(basePathRegEx, '');\r\n};\r\n\r\n/**\r\n * Render all components that use path hooks.\r\n */\r\nconst updatePathHooks = () => {\r\n\tconst now = Date.now();\r\n\tpathUpdaters.forEach(cb => cb(now));\r\n};\r\n\r\n/**\r\n * Called from within the router. This returns either the current windows url path\r\n * or a already reduced path, if a parent router has already matched with a finishing\r\n * wildcard before.\r\n * @param {string} [parentRouterId]\r\n * @returns {string}\r\n */\r\nexport const getWorkingPath = (parentRouterId) => {\r\n\tif (!parentRouterId) {\r\n\t\treturn isNode ? customPath : window.location.pathname.replace(basePathRegEx, '') || '/';\r\n\t}\r\n\tconst stackEntry = stack[parentRouterId];\r\n\tif (!stackEntry) {\r\n\t\tthrow 'wth';\r\n\t}\r\n\r\n\treturn stackEntry.reducedPath !== null ? stackEntry.reducedPath || '/' : window.location.pathname;\r\n};\r\n\r\nconst processStack = () => Object.values(stack).forEach(process);\r\n\r\n/**\r\n * This function takes two objects and compares if they have the same\r\n * keys and their keys have the same values assigned, so the objects are\r\n * basically the same.\r\n * @param {object} objA\r\n * @param {object} objB\r\n * @return {boolean}\r\n */\r\nconst objectsEqual = (objA, objB) => {\r\n\tconst objAKeys = Object.keys(objA);\r\n\tconst objBKeys = Object.keys(objB);\r\n\r\n\tconst valueIsEqual = key => objB.hasOwnProperty(key) && objA[key] === objB[key];\r\n\r\n\treturn (\r\n\t\tobjAKeys.length === objBKeys.length\r\n\t\t&& objAKeys.every(valueIsEqual)\r\n\t);\r\n};\r\n\r\nif (!isNode) {\r\n\twindow.addEventListener('popstate', (e) => {\r\n\t\tconst nextPath = interceptRoute(currentPath, location.pathname);\r\n\r\n\t\tif (!nextPath || nextPath === currentPath) {\r\n\t\t\te.preventDefault();\r\n\t\t\te.stopPropagation();\r\n\t\t\thistory.pushState(null, null, currentPath);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tcurrentPath = nextPath;\r\n\r\n\t\tif (nextPath !== location.pathname) {\r\n\t\t\thistory.replaceState(null, null, nextPath);\r\n\t\t}\r\n\t\tprocessStack();\r\n\t\tupdatePathHooks();\r\n\t});\r\n}\r\n\r\nconst emptyFunc = () => null;\r\n\r\n/**\r\n * This will calculate the match of a given router.\r\n * @param {object} stackObj\r\n * @param {boolean} [directCall] If its not a direct call, the process function might trigger a component render.\r\n */\r\nconst process = (stackObj, directCall) => {\r\n\tconst {\r\n\t\trouterId,\r\n\t\tparentRouterId,\r\n\t\troutes,\r\n\t\tsetUpdate,\r\n\t\tresultFunc,\r\n\t\tresultProps,\r\n\t\treducedPath: previousReducedPath\r\n\t} = stackObj;\r\n\r\n\tconst currentPath = getWorkingPath(parentRouterId);\r\n\tlet route = null;\r\n\tlet targetFunction = null;\r\n\tlet targetProps = null;\r\n\tlet reducedPath = null;\r\n\tlet anyMatched = false;\r\n\r\n\tfor (let i = 0; i < routes.length; i++) {\r\n\t\t[route, targetFunction] = routes[i];\r\n\t\tconst [regex, groupNames] = preparedRoutes[route]\r\n\t\t\t? preparedRoutes[route]\r\n\t\t\t: prepareRoute(route);\r\n\r\n\t\tconst result = currentPath.match(regex);\r\n\t\tif (!result) {\r\n\t\t\ttargetFunction = emptyFunc;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (groupNames.length) {\r\n\t\t\ttargetProps = {};\r\n\t\t\tfor (let j = 0; j < groupNames.length; j++) {\r\n\t\t\t\ttargetProps[groupNames[j]] = result[j + 1];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treducedPath = currentPath.replace(result[0], '');\r\n\t\tanyMatched = true;\r\n\t\tbreak;\r\n\t}\r\n\r\n\tif (!stack[routerId]) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (!anyMatched) {\r\n\t\troute = null;\r\n\t\ttargetFunction = null;\r\n\t\ttargetProps = null;\r\n\t\treducedPath = null;\r\n\t}\r\n\r\n\tconst funcsDiffer = resultFunc !== targetFunction;\r\n\tconst pathDiffer = reducedPath !== previousReducedPath;\r\n\tlet propsDiffer = true;\r\n\r\n\tif (!funcsDiffer) {\r\n\t\tif (!resultProps && !targetProps) {\r\n\t\t\tpropsDiffer = false;\r\n\t\t} else {\r\n\t\t\tpropsDiffer = !(resultProps && targetProps && objectsEqual(resultProps, targetProps) === true);\r\n\t\t}\r\n\r\n\t\tif (!propsDiffer) {\r\n\t\t\tif (!pathDiffer) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tconst result = funcsDiffer || propsDiffer\r\n\t\t? targetFunction\r\n\t\t\t? targetFunction(targetProps)\r\n\t\t\t: null\r\n\t\t: stackObj.result;\r\n\r\n\tObject.assign(stack[routerId], {\r\n\t\tresult,\r\n\t\treducedPath,\r\n\t\tmatchedRoute: route,\r\n\t\tpassContext: route ? route.substr(-1) === '*' : false\r\n\t});\r\n\r\n\tif (!directCall && (funcsDiffer || propsDiffer || route === null)) {\r\n\t\tsetUpdate(Date.now());\r\n\t}\r\n};\r\n\r\n/**\r\n * If a route returns a function, instead of a react element, we need to wrap this function\r\n * to eventually wrap a context object around its result.\r\n * @param RouteContext\r\n * @param originalResult\r\n * @returns {function(): *}\r\n */\r\nconst wrapperFunction = (RouteContext, originalResult) => function (){\r\n\treturn (\r\n\t\t<RouteContext>{originalResult.apply(originalResult, arguments)}</RouteContext>\r\n\t);\r\n};\r\n\r\n/**\r\n * Pass an object to this function where the keys are routes and the values\r\n * are functions to be executed when a route matches. Whatever your function returns\r\n * will be returned from the hook as well into your react component. Ideally you would\r\n * return components to be rendered when certain routes match, but you are not limited\r\n * to that.\r\n * @param {object} routeObj {\"/someRoute\": () => <Example />}\r\n */\r\nexport const useRoutes = (routeObj) => {\r\n\t// Each router gets an internal id to look them up again.\r\n\tconst [routerId] = React.useState(componentId);\r\n\tconst setUpdate = React.useState(0)[1];\r\n\t// Needed to create nested routers which use only a subset of the URL.\r\n\tconst parentRouterId = React.useContext(ParentContext);\r\n\r\n\t// If we just took the last ID, increase it for the next hook.\r\n\tif (routerId === componentId) {\r\n\t\tcomponentId += 1;\r\n\t}\r\n\r\n\t// Removes the router from the stack after component unmount - it won't be processed anymore.\r\n\tReact.useEffect(() => () => delete stack[routerId], [routerId]);\r\n\r\n\tlet stackObj = stack[routerId];\r\n\r\n\tif (stackObj && stackObj.originalRouteObj !== routeObj) {\r\n\t\tstackObj = null;\r\n\t}\r\n\r\n\tif (!stackObj) {\r\n\t\tstackObj = {\r\n\t\t\trouterId,\r\n\t\t\toriginalRouteObj: routeObj,\r\n\t\t\troutes: Object.entries(routeObj),\r\n\t\t\tsetUpdate,\r\n\t\t\tparentRouterId,\r\n\t\t\tmatchedRoute: null,\r\n\t\t\treducedPath: null,\r\n\t\t\tpassContext: false,\r\n\t\t\tresult: null\r\n\t\t};\r\n\r\n\t\tstack[routerId] = stackObj;\r\n\r\n\t\tprocess(stackObj, true);\r\n\t}\r\n\r\n\tReact.useDebugValue(stackObj.matchedRoute);\r\n\r\n\tif (!stackObj.matchedRoute) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tlet result = stackObj.result;\r\n\r\n\tif (!stackObj.passContext) {\r\n\t\treturn result;\r\n\t} else {\r\n\t\tconst RouteContext = ({children}) => <ParentContext.Provider value={routerId}>{children}</ParentContext.Provider>;\r\n\r\n\t\tif (typeof result === 'function') {\r\n\t\t\treturn wrapperFunction(RouteContext, result);\r\n\t\t}\r\n\r\n\t\treturn React.isValidElement(result) && result.type !== RouteContext\r\n\t\t\t? <RouteContext>{result}</RouteContext>\r\n\t\t\t: result;\r\n\t}\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}