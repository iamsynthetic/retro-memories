{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useControlledInterceptor = void 0;\nvar _react = _interopRequireDefault(require(\"react\"));\nvar _interceptor = require(\"./interceptor\");\nvar _router = require(\"./router\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\n/**\r\n * This is a controlled version of the interceptor which cancels any navigation intent\r\n * and hands control over it to your calling component.\r\n *\r\n * `interceptedPath` is initially `null` and will be set to the target path upon navigation.\r\n * `confirmNavigation` is the callback to be called to stop the interception and navigate to the last path.\r\n * `resetPath` is a callback that resets `interceptedPath` back to `null`.\r\n *\r\n * @returns {Array} [interceptedPath, confirmNavigation, resetPath]\r\n */\nvar useControlledInterceptor = function useControlledInterceptor() {\n  var _React$useState = _react.default.useState(null),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    interceptedPath = _React$useState2[0],\n    setInterceptedPath = _React$useState2[1];\n  var interceptorFunction = _react.default.useMemo(function () {\n    return function (currentPath, nextPath) {\n      setInterceptedPath(nextPath);\n      return currentPath;\n    };\n  }, [setInterceptedPath]);\n  var stopInterception = (0, _interceptor.useInterceptor)(interceptorFunction);\n  var confirmNavigation = _react.default.useMemo(function () {\n    return function () {\n      stopInterception();\n      (0, _router.navigate)(interceptedPath);\n    };\n  }, [stopInterception, interceptedPath]);\n  var resetPath = _react.default.useMemo(function () {\n    return function () {\n      return setInterceptedPath(null);\n    };\n  }, [setInterceptedPath]);\n  return [interceptedPath, confirmNavigation, resetPath, stopInterception];\n};\nexports.useControlledInterceptor = useControlledInterceptor;","map":{"version":3,"names":["_react","_interopRequireDefault","require","_interceptor","_router","useControlledInterceptor","_React$useState","default","useState","_React$useState2","_slicedToArray","interceptedPath","setInterceptedPath","interceptorFunction","useMemo","currentPath","nextPath","stopInterception","useInterceptor","confirmNavigation","navigate","resetPath"],"sources":["/Users/tomo/Documents/code/projects/react/retro-memories/node_modules/hookrouter/src/controlledInterceptor.js"],"sourcesContent":["import React from 'react';\r\nimport {useInterceptor} from \"./interceptor\";\r\nimport {navigate} from \"./router\";\r\n\r\n/**\r\n * This is a controlled version of the interceptor which cancels any navigation intent\r\n * and hands control over it to your calling component.\r\n *\r\n * `interceptedPath` is initially `null` and will be set to the target path upon navigation.\r\n * `confirmNavigation` is the callback to be called to stop the interception and navigate to the last path.\r\n * `resetPath` is a callback that resets `interceptedPath` back to `null`.\r\n *\r\n * @returns {Array} [interceptedPath, confirmNavigation, resetPath]\r\n */\r\nexport const useControlledInterceptor = () => {\r\n\tconst [interceptedPath, setInterceptedPath] = React.useState(null);\r\n\r\n\tconst interceptorFunction = React.useMemo(\r\n\t\t() => (currentPath, nextPath) => {\r\n\t\t\tsetInterceptedPath(nextPath);\r\n\t\t\treturn currentPath;\r\n\t\t},\r\n\t\t[setInterceptedPath]\r\n\t);\r\n\r\n\tconst stopInterception = useInterceptor(interceptorFunction);\r\n\r\n\tconst confirmNavigation = React.useMemo(\r\n\t\t() => () => {\r\n\t\t\tstopInterception();\r\n\t\t\tnavigate(interceptedPath);\r\n\t\t},\r\n\t\t[stopInterception, interceptedPath]\r\n\t);\r\n\r\n\tconst resetPath = React.useMemo(\r\n\t\t() => () => setInterceptedPath(null),\r\n\t\t[setInterceptedPath]\r\n\t);\r\n\r\n\treturn [interceptedPath, confirmNavigation, resetPath, stopInterception];\r\n};\r\n"],"mappings":";;;;;;AAAA,IAAAA,MAAA,GAAAC,sBAAA,CAAAC,OAAA;AACA,IAAAC,YAAA,GAAAD,OAAA;AACA,IAAAE,OAAA,GAAAF,OAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;AAUO,IAAMG,wBAAwB,GAAG,SAA3BA,wBAA2BA,CAAA,EAAM;EAAA,IAAAC,eAAA,GACCN,MAAA,CAAAO,OAAA,CAAMC,QAAN,CAAe,IAAf,CADD;IAAAC,gBAAA,GAAAC,cAAA,CAAAJ,eAAA;IACtCK,eADsC,GAAAF,gBAAA;IACrBG,kBADqB,GAAAH,gBAAA;EAG7C,IAAMI,mBAAmB,GAAGb,MAAA,CAAAO,OAAA,CAAMO,OAAN,CAC3B;IAAA,OAAM,UAACC,WAAD,EAAcC,QAAd,EAA2B;MAChCJ,kBAAkB,CAACI,QAAD,CAAlB;MACA,OAAOD,WAAP;IACA,CAHD;EAAA,CAD2B,EAK3B,CAACH,kBAAD,CAL2B,CAA5B;EAQA,IAAMK,gBAAgB,GAAG,IAAAd,YAAA,CAAAe,cAAA,EAAeL,mBAAf,CAAzB;EAEA,IAAMM,iBAAiB,GAAGnB,MAAA,CAAAO,OAAA,CAAMO,OAAN,CACzB;IAAA,OAAM,YAAM;MACXG,gBAAgB;MAChB,IAAAb,OAAA,CAAAgB,QAAA,EAAST,eAAT;IACA,CAHD;EAAA,CADyB,EAKzB,CAACM,gBAAD,EAAmBN,eAAnB,CALyB,CAA1B;EAQA,IAAMU,SAAS,GAAGrB,MAAA,CAAAO,OAAA,CAAMO,OAAN,CACjB;IAAA,OAAM;MAAA,OAAMF,kBAAkB,CAAC,IAAD,CAAxB;IAAA,CAAN;EAAA,CADiB,EAEjB,CAACA,kBAAD,CAFiB,CAAlB;EAKA,OAAO,CAACD,eAAD,EAAkBQ,iBAAlB,EAAqCE,SAArC,EAAgDJ,gBAAhD,CAAP;AACA,CA3BM"},"metadata":{},"sourceType":"script","externalDependencies":[]}